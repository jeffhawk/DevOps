name: CI/CD - DevOps Fase 2 - React/Docker/ECS

on:
  push:
    branches: ["Fase-2"]
  workflow_dispatch:

jobs:
  # 1 - Seguindo as orientações das aulas, estou seguindo as melhores práticas de CI/CD, irei realizar os testes e o build no ambiente do github antes.
  build-static:
    name: Validação e build da aplicação
    runs-on: ubuntu-latest
    steps:
      - name: Checkout do código
        uses: actions/checkout@v4

      - name: Cache do npm
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-npm-cache-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-npm-cache-

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test -- --watchAll=false

      - name: Audit packages
        run: npm audit --production --audit-level=moderate || true

      - name: Build
        run: npm run build

      - name: Verificar a pasta build
        run: ls -la build

      - name: Verificar se existe index.html
        run: |
            if [ ! -f build/index.html ]; then
              echo "index.html não encontrado!"
              exit 1
            else
              echo "index.html encontrado"
            fi

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build
          path: build/

  # 2 - Resolvi dedicar um tempo e deixar mais automatizado utilizando o terraform para realizar os passos de criação da infra no AWS (ECR + ECS)
  terraform-provision:
    name: Criar infraestrutura AWS
    needs: build-static
    runs-on: ubuntu-latest
    outputs:
      ecr_repo: ${{ steps.tf_outputs.outputs.ecr_repo }}
      ecs_cluster: ${{ steps.tf_outputs.outputs.ecs_cluster }}
      ecs_service: ${{ steps.tf_outputs.outputs.ecs_service }}
    steps:
      - name: Checkout do código
        uses: actions/checkout@v4

      - name: Credenciais AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-1

      - name: Instalar Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.5

      - name: Inicializar Terraform
        working-directory: infra/terraform
        run: terraform init -input=false

      - name: Verificar formatação
        working-directory: infra/terraform
        run: terraform fmt -check

      - name: Validar configuração
        working-directory: infra/terraform
        run: terraform validate

      - name: Aplicar Terraform
        working-directory: infra/terraform
        run: terraform apply -auto-approve

      - name: Upload do state
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state
          path: infra/terraform/terraform.tfstate

      - name: Capturar outputs do Terraform
        id: tf_outputs
        working-directory: infra/terraform
        run: |
          # ecr_repo=$(terraform output ecr_repository_url 2>/dev/null | grep -Eo '^[^ ]+$' | grep -v bucket_name | grep -v '0\.' | grep -v '^0$' | tr -d '\n\r')
          # ecs_cluster=$(terraform output ecs_cluster_name 2>/dev/null | grep -Eo '^[^ ]+$' | grep -v bucket_name | grep -v '0\.' | grep -v '^0$' | tr -d '\n\r')
          # ecs_service=$(terraform output ecs_service_name 2>/dev/null | grep -Eo '^[^ ]+$' | grep -v bucket_name | grep -v '0\.' | grep -v '^0$' | tr -d '\n\r')

          # ecr_repo=$(echo $ecr_repo | sed 's/^"//; s/"$//' | xargs)
          # ecs_cluster=$(echo $ecs_cluster | sed 's/^"//; s/"$//' | xargs)
          # ecs_service=$(echo $ecs_service | sed 's/^"//; s/"$//' | xargs)

          # echo "ECR Repository URL: $ecr_repo"
          # echo "ECS Cluster Name: $ecs_cluster"
          # echo "ECS Service Name: $ecs_service"
          echo "ecr_repo<<EOF" >> $GITHUB_OUTPUT
          terraform output -raw ecr_repository_url >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "ecs_cluster<<EOF" >> $GITHUB_OUTPUT
          terraform output -raw ecs_cluster_name >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "ecs_service<<EOF" >> $GITHUB_OUTPUT
          terraform output -raw ecs_service_name >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT


          echo "ecr_repo=$ecr_repo" >> $GITHUB_OUTPUT
          echo "ecs_cluster=$ecs_cluster" >> $GITHUB_OUTPUT
          echo "ecs_service=$ecs_service" >> $GITHUB_OUTPUT

      - name: Verificar variáveis capturadas 1
        run: |
          echo "ECR: ${{ steps.tf_outputs.outputs.ecr_repo }}"
          echo "Cluster: ${{ steps.tf_outputs.outputs.ecs_cluster }}"
          echo "Service: ${{ steps.tf_outputs.outputs.ecs_service }}"

  # 3 - Build e push da imagem Docker para o ECR
  docker-build-push:
    name: Build e push da imagem Docker
    needs: terraform-provision
    runs-on: ubuntu-latest
    steps:
      - name: Checkout do código
        uses: actions/checkout@v4

      - name: Baixar o build
        uses: actions/download-artifact@v4
        with:
          name: build
          path: build/

      - name: Configurar credenciais AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-1

      - name: Login no Amazon ECR
        run: |
          aws ecr get-login-password --region us-east-1 \
          | docker login --username AWS --password-stdin ${{ needs.terraform-provision.outputs.ecr_repo }}

      - name: Build e push da imagem
        run: |
          docker build -t hotwheels .
          docker tag hotwheels:latest ${{ needs.terraform-provision.outputs.ecr_repo }}:latest
          docker push ${{ needs.terraform-provision.outputs.ecr_repo }}:latest

  # 4 - Deploy no ECS
  ecs-deploy:
    name: Deploy no ECS
    needs: docker-build-push
    runs-on: ubuntu-latest
    steps:
      - name: Configurar credenciais AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-1

      - name: Atualizar ECS Service
        run: |
          echo "Verificando as variáveis de output"
          echo "Cluster: ${{ needs.terraform-provision.outputs.ecs_cluster }}"
          echo "Serviço: ${{ needs.terraform-provision.outputs.ecs_service }}"
          aws ecs update-service \
            --cluster ${{ needs.terraform-provision.outputs.ecs_cluster }} \
            --service ${{ needs.terraform-provision.outputs.ecs_service }} \
            --force-new-deployment

  rollback:
    name: Rollback da infraestrutura
    if: failure()
    needs: [build-static, terraform-provision, docker-build-push, ecs-deploy]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout do código
        uses: actions/checkout@v4

      - name: Configurar credenciais AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-1

      - name: Instalar Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.5

      - name: Inicializar Terraform
        working-directory: infra/terraform
        run: terraform init -input=false

      - name: Baixar o state
        uses: actions/download-artifact@v4
        with:
          name: terraform-state
          path: infra/terraform/

      - name: Executar rollback com destroy
        working-directory: infra/terraform
        run: terraform destroy -auto-approve